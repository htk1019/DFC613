## 9강. 팩터예측, 포트폴리오 비중

### 팩터 노출도 및 프리미엄 예측

펀더멘털, 이코노믹의 두 가지의 팩터 모델을 살펴 봤습니다. 두 팩터 모델의 근간은 같습니다.
결국 두 모델 모두 "평균 주식 수익률은 팩터 프리미엄과 팩터 노출도의 곱과 같다."는 아이디어에서 시작합니다.

팩터모델은 과거 데이터를 기반으로 구현 됩니다. 
연구자는 미래 주식 수익률을 예측하고자 하기 때문에 미래 팩터 프리미엄과 미래 팩터 노출도가 필요합니다.
T+1 시점의 주식 수익률을 예측하기 위해서는 우리는 사실 T+1 시점의 팩터 프리미엄과 팩터 노출도가 필요한 것입니다.

$$
r_{i,T+1} = \alpha_i + \beta_{i,T+1}'f_{T+1} + \epsilon_{i,T+1}
$$

여기서 $\alpha_i$는 상수항이고, $\beta_{i,T+1}$은 T+1 시점의 주식 i에 대한 노출도를 포함한 K차원의 벡터이며 $f_{T+1}$은 T+1 시점의 팩터 프리미엄 K차원 벡터입니다.
$\epsilon_{i,T+1}$ 는 주식 i의 수익률이 모델의 기대 수익률에서 벗어난 편차입니다.

이 모델을 계산하기 위해서는 예측이 필요합니다. 예측을 통해 팩터 프리미엄과 팩터 노출도의 미래 값을 찾으면 미래 주식 수익률을 예측할 수 있습니다.

#### 예측은 언제 필요한가?

펀더멘털 팩터 모델의 간단한 버전을 사용할 경우, 미래 주식 수익률을 예측하기 위해 따로 팩터 노출도나 팩터 프리미엄의 미래 값을 예측할 필요가 없습니다.

펀더멘털 팩터 모델에서 팩터 노출도$\beta_{i,t}$는 주식이나 포트폴리오의 팩터에 대한 B/P, E/P 같은 현재의 값입니다. 시간 t에서 이 값을 우리는 이미 알고 있습니다. 그리고 그 값으로 $r_{i,T+1}$을 예측하는 모델링을 했습니다. 수익률 회귀분석을 어떻게 했는지 기억해보세요. 해당 시점의 B/P 같은 팩터 노출도를 그 시점 이후의 수익률과 회귀분석 했습니다. 즉 우리는 t+1의 종속변수 $r_{i,t+1}$을 예측하기 위해 $\beta_{i,t+1}$을 예측할 필요가 없습니다.

팩터 프리미엄도 예측할 필요가 없습니다. 모든 유형의 팩터 모델에서는 추정치가 일정 기간 동안 유지될 것이라고 가정하는 것이 일반적입니다. 따라서 펀더멘털 팩터모델에서는 시간 1,...T에서 추정된 팩터 프리미엄 f가 T+1에도 유효하다고 가정합니다. 그러기에 팩터 프리미엄도 예측할 필요가 없습니다. **이런 이유때문에 펀더멘털 팩터 모델이 선호되는 부분이 있습니다.**

예측은 이코노믹 팩터 모델을 사용할 때 필요합니다. 이코노믹 팩터 모델에서는 설명 변수인 팩터 프리미어 값을 예측 해야 합니다. 이코노믹 팩터 모델에서 설명 변수인 팩터 프리미엄은 GDP, CPI, 지수 수익률과 같은 시기의 값이고 이는 시간 T가 끝날 때만 알수 있습니다. 따라서 시간 T가 끝날때 우리는 T+1 시간에 대한 팩터 프리미엄 값을 알지 못하므로 $f_{T+1}$을 알지 못하면 $r_{i,T+1}$을 예측할 수 없습니다.

모델링의 결과인 팩터 노출도는 일정하게 유지된다고 봅니다. $\hat{\beta}_i$는 T+1 기간에도 여전히 유요합니다.

그럼 예측은 어떻게 수행해야 합니까?

#### 외부 예측 기관의 예측치를 활용

신뢰할 수 있는 외부 예측값이 존재할 때, 포트폴리오 매니저는 내부에서 예측을 시도하기보다는 외부 예측값들을 사용해야 합니다. 팩터 프리미엄 예측은 예측을 발표하는 경제학자들, 다양한 경제 예측 기관, 그리고 다양한 회사의 연구 분석가들로부터 얻을 수 있습니다. 

서로 다른 J명의 예측자들이 팩터 프리미엄 fT+1에 대한 예측값을 제공했다고 가정합니다. 모든 예측자의 신뢰도가 동일하다면, $f_{T+1}$의 최적 예측값은 J개의 예측값의 평균이 됩니다. 

$$
\hat{E}(f_{T+1}) = \frac{1}{J}\sum_{j=1}^{J}f^{(j)}_{T+1}
$$

포트폴리오 매니저는 예측이 얼마나 신뢰할 수 있는지에 대해서도 관심을 가져야 합니다. J명의 예측자들의 예측이 어느정도 일치하면 예측이 크게 다를 때 보다 예측에 대해 더 확신을 가질 수 있습니다. 따라서 예측의 분산을 통해 예측의 신뢰도를 계산합니다. 

$$
    \hat{V}(f_{T+1})
    =
    \frac{1}{J}\sum_{j=1}^{J}
    f^{(j)}_{T+1}f'^{(j)}_{T+1}
    -
    \hat{E}(f_{T+1})\hat{E}(f'_{T+1})
$$

이 분산의 역을 신뢰도의 척도로 사용할 수 있습니다.
$f_{T+1}$이 정규 분포를 따른다고 가정하면 주어진 $f_{T+1}$의 평균과 분산을 통해 예측치의 분포를 구하는 작업이 완료됩니다.

#### 모델 기반 예측

예측은 대부분의 포트폴리오 매니저에게 전문 분야는 아닙니다. 심지어 정량적 분석을 잘 다루는 매니저에게도 예측은 까다로운 작업이며, 종종 효율적으로 시간을 사용하지 못하게 합니다. 그렇지만 특정 팩터를 효과적으로 예측하는 사내 모델이 존재한다면, 이를 활용하면 포트폴리오 성과 향상에 도움이 될 수 있습니다.

간단한 예로, 시장 팩터를 포함한 경제 팩터 모델을 활용하여 팩터 프리미엄을 예측하는 모델을 생각해보겠습니다

$$
    r_{T+1}^{SP500} = a + blI_t + \epsilon_{t+1}
$$

LI는 선행 경제 지표값을 나타냅니다. 선행 경제 지표는 미국 경제분석국의 선행 지표나 주당 평균 근무 시간, 초기 실업수당 청구 건수, 소비재 신규 주문, 민감한 원자재 가격, 소비자 신뢰도 변화, GDP 변화 등과 같은 지표 중 하나일 수 있습니다.

이 모델의 예측 능력을 검증하려면 간단한 테스트가 필요합니다. 먼저, 모델이 지난 데이터를 통해 어떤 관계를 보이는지 추정합니다. 만약 b의 추정치가 통계적으로 유의미하다면, 이 모델은 경제 팩터 모델을 활용한 시장 팩터의 예측에 사용될 수 있습니다. 이코노믹 팩터 모델에 추가적인 다른 팩터들도 포함되어 있다면, 회귀 분석을 통해 다른 팩터의 예측값도 이와 같은 방식으로 얻을 수 있습니다. 이번 예시에서는 T월의 선행 경제 지표를 바탕으로, 이 모델을 사용해 T+1 시점의 팩터 프리미엄인 S&P500의 수익률을 예측한 것입니다.

포인트는 회귀 분석을 이용해 팩터의 값을 예측한다는 것입니다. T월의 경기 선행지표(LI)가 주어지면 앞의 모델에서 결정된 수익률과 추정 분산을 사용하여 T+1의 팩터 프리미엄 (S&P500 수익률)을 예측하고 이를 주식 모델링에 사용할 수 있습니다.

#### 통계적 예측 기법을 사용

포트폴리오 매니저가 외부 팩터 프리미엄 예측에 만족하지 않는 경우, 그 원인은 예측자를 신뢰하지 않거나 모델에 적합한 외부 예측이 없기 때문일 수 있습니다. 더불어, 효과적인 사내 예측 모델이 존재하지 않을 가능성도 있습니다. 이런 상황에서 매니저는 기본적인 계량 경제학이나 통계적 예측 방법론을 적용해 볼 수 있습니다.

대표적인 방법으로는 벡터자기회귀(VAR)기법이 있습니다.

여기서 예측하고자 하는 팩터 프리미엄은 과거 팩터 프리미엄의 선형함수 입니다.

$$
f_t = \gamma_0 + \gamma_1f_{t-1} + ... \gamma_Lf_{t-L} + \omega_t, t=L+1,...T
$$

VAR 모델에 대한 자세한 설명은 생략하겠습니다.
이 모델링 전략을 고려할 때 결정해야 할 것은 방정식에 얼마나 많은 과거 값을 사용할 것인가 뿐입니다. 과거 값을 많이 포함하면 정확도가 올라갑니다. 그러나 과거 값을 많이 포함하면 추정해야 하는 매개변수의 수가 크게 증가하며 오버피팅의 가능성도 높아집니다.

### 주식 수익률 예측

이코노믹 팩터 모델에서 필요한 시간 T+1에 대한 팩터 프리미엄의 분포 즉 $f_{T+1}$을 예측하는 방법을 알아봤습니다. 앞서 언급 했듯이 T+1 시점의 팩터 노출도인 $\beta_{i,T+1}$은 관측 가능하거나(펀더멘털 팩터모델), T시점까지 주정된 팩터 노출도와 동일(이코노믹 팩터 모델)하다고 가정합니다.

정규 분포를 가정하면 주식 수익률의 분포는 평균과 분산을 추정하여 지정됩니다.

$$
r_{i,T+1} = \alpha_i + \beta'_{i,T+1}f_{T+1} + \epsilon_{i,T+1}
$$

주식 수익률의 평균과 분산은 다음과 같습니다.

$$
E(r_{i,T+1}) = \alpha_i + \beta'_{i,T+1}E({f_{T+1}})
$$

$$
V(r_{i,T+1}) = \beta'_{i,T+1}V(f_{T+1})\beta_{i,T+1} + V(\epsilon_{i,T+1})
$$

이제 기대수익률과 기대위험에 대한 추정이 되었으므로 비중을 결정할 수 있습니다.

### 포트폴리오 비중

주식 가중치를 생성하는 방법에는 여러 가지가 있습니다. 일부 방법은 매우 초보적인 방법으로, 예를 들어 자신이 속한 종목군에서 가장 좋은 종목을 골라 동일하게 가중치를 부여하는 것입니다. 또 다른 간단한 방법은 많은 지수처럼 시가총액에 따라 주식에 가중치를 부여하는 것입니다. 시가총액 가중치를 조금 더 복잡하게 변형하면 시가총액의 제곱근으로 
가중치를 부여하는 것입니다. 조금 더 복잡한 방법은 마코위츠 포트폴리오 이론의 아이디어를 바탕으로 포트폴리오의 기대 수익률을 극대화하고 전체 위험을 최소화하는 방식으로 주식에 가중치를 부여하는 것입니다. 한번 알아 봅시다.

벤치마크를 기준으로 포트폴리오를 관리하는 대부분의 포트폴리오 매니저의 경우 가중치를 결정할 때 목표 벤치마크와 관련 있습니다. 예를 들어, 매니저는 종목의 가중 평균 팩터 노출이 벤치마크의 가중 평균 팩터 노출과 같도록 종목에 가중치를 부여할 수 있습니다. 아니면  벤치마크 대비 포트폴리오의 허용 추적 오차에 제한을 두면서 초과 기대 수익을 극대화할 수 있도록 가중치를 할당 할 수도 있습니다.

또한 포트폴리오 이론에 기반한 비중 결정은 기대 수익률을 극대화 하고 위험을 최소화 하는 것이 목표입니다. 이를 위해 매니저는 각 주식의 기대 수익률, 각 주식의 분산, 주식들 간의 공분산을 알아야 합니다. 그래야 포트폴리오의 위험을 알수 있기 때문입니다.


매니저는 포트폴리오를 만들때 특정 제약을 따르도록 비중을 결정할 수도 있습니다. 예를 들어 공매도를 금지하거나, 각 주식에 할당된 비중에 범위를 지정할 수도 있습니다. 이후 매니저는 매개변수와 제약 조건을 고려한 이차 최적화 알고리즘을 통해 포트폴리오의 최적 가중치를 찾습니다.

이번 파트에서는 포트폴리오 가중치를 결정하는 수학적, 통계적 접근법에 대해 알아봅니다.

이번 과정은 상용 소프트웨어를 사용하는 큰 회사의 포트폴리오 관리자들이라면 알아야 하는 내용입니다. 위험 모델의 메커니즘을 이해 도움이 될 것입니다. 회사 내 자체 위험 모델과 포트폴리오 최적화 도구를 구축하고자 하는 퀀트에게는 이 파트가 매우 중요할 것입니다.

일단 크게 두 파트로 나눠 벤치마크가 있는 포트폴리오와 없는 포트폴리오의 비중결정 방법을 살펴봅니다.

**벤치마크가 없는 포트폴리오 비중 결정**
- ad-hoc 방법 : 다양한 경험 법칙을 사용하여 주식에 가중치를 부여합니다.

- 평균 분산 최적화 방법 : 주어진 기대 수익률을 넘어 섰다면 포트폴리오의 위험을 최소화 하도록 비중을 할당합니다.


**벤치마크가 있는 포트폴리오 비중 결정**
- ad-hoc 가중치 방법
- 계층화 샘플링(stratification) 방법 
- 팩터 노출도 타겟팅: 포트폴리오와 벤치마크의 평균 팩터 노출이 일치하도록 주식의 가중치를 결정합니다.
- 추적 오차 최소화: 지정된 임계값 이하의 추적 오차를 유지하면서 포트폴리오의 최대 기대 수익률 또는 α를 달성하기 위한 최적 비중을 결정합니다.

하나씩 알아보겠습니다

#### Ad-hoc 방법

가장 간단한 방법은 모든 주식에 동일 가중치를 부여하는 것입니다. 이 방식은  확실히 빠르고 간단하지만 한 가지 큰 결점이 있습니다. 주식의 위험도 기대 수익률도 반영하지 않는다는 것입니다. 선택한 종목의 예상 수익률과 위험에 대한 정보가 부족한 경우에는 의미가 있습니다.

그 다음 단순한 방법은 시가총액 가중치로 할당하는 것입니다. 시가 총액 가중치에는 몇가지 변형 버전이 있습니다. 예를들어 일부 매니저는 시가총액 제곱근으로 주식에 가중치를 부여하기도 합니다.

체계화 할수 없는 매니저가 자의로 비중을 할당하는 방법이 있습니다.

Ad-hoc 방식은 사실 퀀트 모델이라고 말할 수 없기 떄문에 간단히만 짚고 넘어가지만 모든 투자자들이 가장 보편적으로 쓰고 있는 방법입니다. 제가 경험한 국내 액티브 펀드 운용은 대부분 Ad-hoc 방식을 선택합니다.


#### 평균-분산 최적화

기대 수익률과 분산이 주어지면 최소 위험을 갖는 포트폴리오를 찾을 수 있습니다.
동일한 기대 수익률을 가진 포트폴리오 중에서 사전에 측정된 기대 위험이 가장 낮은 포트폴리오를 찾을 수 있습니다. 이를 평균 분산 최적화 또는 MVO라고 합니다.

간단하게 말하면, 우리는 가장 수익률이 높으면서도 위험이 낮은 포트폴리오를 찾고자 합니다. 혹은 정해진 위험 범위 내에서 가장 높은 수익률을 가진 포트폴리오를 찾을 수도 있습니다.

하지만, 가능한 모든 조합의 포트폴리오 수익률과 위험을 하나하나 계산하는 것은 시간이 너무 많이 듭니다. 왜냐하면 가능한 포트폴리오 조합이 너무 많기 때문입니다. 그래서 이차 프로그래밍이라는 방법을 사용하여, 효율적으로 최적의 포트폴리오를 찾습니다.

다음은 파이썬으로 구현한 예시입니다. 이론은 뒤에 다시 살펴봅니다.

목표 : 위험(분산)이 낮은 포트폴리오

```python
from scipy.optimize import minimize

# 주식 A와 B의 기대수익률, 분산, 공분산
mu_A = 0.03  # A의 기대수익률
mu_B = 0.05  # B의 기대수익률
var_A = 0.10  # A의 분산
var_B = 0.15  # B의 분산
cov_AB = -0.03  # A와 B의 공분산

# 포트폴리오의 분산을 계산하는 함수
def portfolio_variance(w):
    return w**2 * var_A + (1 - w)**2 * var_B + 2 * w * (1 - w) * cov_AB

# 분산을 최소화하는 w값을 찾음
result = minimize(portfolio_variance, 0.5, bounds=[(0, 1)])
optimal_weight_A = result.x[0]
optimal_weight_B = 1 - optimal_weight_A

optimal_weight_A, optimal_weight_B
```

```
(0.5806451573768154, 0.41935484262318456)
```

분산을 최소화 하기 위한 주식 A의 최적화된 비중은 약 58.06%이며, 주식 B의 최적화된 비중은 약 41.94%입니다.

여기서 사용한 minimize 함수의 주요 인자들에 대해 설명하겠습니다
- 첫 번째 인자 (함수): 최소화하려는 목적함수입니다. 이 경우에는 portfolio_variance라는 함수를 사용했으며, 이 함수는 주식 A와 B의 비중 w에 따른 포트폴리오의 분산을 계산합니다.
- 두 번째 인자 (초기 추측값): 최적화 알고리즘이 시작할 변수의 초기 추측값입니다. 이 경우에는 0.5로 설정했습니다. 즉, A와 B 주식의 비중을 각각 50%로 시작해서 최적의 비중을 찾아나가는 것입니다.
- bounds: 변수의 가능한 범위를 지정합니다. 이 경우에는 w의 값이 0과 1 사이에 있어야 하므로, bounds=[(0, 1)]로 설정했습니다. 이는 주식 A의 비중이 0%에서 100% 사이에 있어야 함을 의미합니다.

일반적으로 포트폴리오 관리자는 몇가지 꼭 필요한 제약 조건을 설정한 다음 나머지는 최적화 도구에 맡깁니다.

**제약조건없이 최적화**

제약 없이 MVO를 사용해 보겠습니다. 일단은 예상 주식 수익률 및 위험 모델을 이미 구축했다고 가정합니다.

첫번째 단계는 개별 주식 수익률에 대한 정보를 백터 $\mu$에 넣었고 분산-공분산 행렬은 $\Sigma$ 에 넣습니다. $\Sigma$는 N을 투자 유니버스에 있는 주식수라고 하면 N X N 개의 행렬이 됩니다.

$$
\mu
=
\begin{bmatrix}
E(r_1) \\
E(r_2) \\
\vdots \\
E(r_N) 
\end{bmatrix}
$$

$$
\mathbf{\Sigma} = \begin{bmatrix}
V(r_1) & C(r_1, r_2) & \dots & C(r_1, r_N) \\
C(r_2, r_1) & V(r_2) & \dots & C(r_2, r_N) \\
\vdots & \vdots & \ddots & \vdots \\
C(r_N, r_1) & C(r_N, r_2) & \dots & V(r_N)
\end{bmatrix}
$$

여기서 $E(r_i)$는 주식 i의 기대수익률 $V(r_i)$는 주식 i의 수익률 분산, $C(r_i,r_j)$는 주식 i의 수익률과 주식 j의 수익률간의 공분산입니다.

포트폴리오 가중치는 벡터 w에 저장합니다.

$$
w
=
\begin{bmatrix}
\omega_1 \\
\omega_2 \\
\vdots \\
\omega_N 
\end{bmatrix}
$$

w는 주식 가중치의 N차원 열벡터입니다. 일반적인 주식 포트폴리오에서 w가 유효한 가중치가 되려면 w에 포함된 모든 요소의 합이 1이어야 합니다.

포트폴리오의 분산은 다음과 같이 계산됩니다

$$
\text{V}(r_P) = w' \Sigma w
$$

여기서 $\text{V}(r_P)$는 포트폴리오의 분산이며, $\Sigma$는 분산-공분산 행렬입니다.

**최적화 목적식**:

목적: 포트폴리오 분산 $\text{V}(r_P)$ 최소화

제약조건:

1. 가중치의 합은 1 : $\sum_{i=1}^{N} \omega_i = 1$
2. 주식의 비중은 0와 1 사이 : $0\leq w_i \leq 1$


이렇게 포트폴리오의 수익률과 분산, 그리고 최적화 문제를 정의할 수 있습니다. 주어진 제약조건 하에서 포트폴리오의 분산을 최소화하는 가중치 벡터 w 를 찾는 것이 주요 목표입니다.

이를 한줄의 식으로 표현하면 다음과 같습니다.

$$
    \underset{w}{min}\ w' \Sigma w \quad s.t. 
    \quad 0 ≤ w ≤ 1
    \quad \quad w'l = 1
$$

여기서 $l$은 1로만 구성된 단위행렬입니다.

아래 코드는 주식이 3개인 경우 최소 분산 포트폴리오를 찾는 코드입니다.

```python
import numpy as np
from scipy.optimize import minimize

# 주식 3개의 기대수익률, 분산, 공분산 설정
expected_returns = np.array([0.04, 0.05, 0.03])  # 각 주식의 기대수익률
cov_matrix = np.array([
    [0.1, 0.002, -0.001],  # 주식 1의 분산, 1과 2의 공분산, 1과 3의 공분산
    [0.002, 0.08, 0.001],  # 주식 2의 분산, 2와 1의 공분산, 2와 3의 공분산
    [-0.001, 0.001, 0.09]  # 주식 3의 분산, 3과 1의 공분산, 3과 2의 공분산
])

# 포트폴리오의 분산을 계산하는 함수
def portfolio_variance(weights):
    return weights.T @ cov_matrix @ weights

# 분산을 최소화하는 비중을 찾는 함수
constraints = (
    {'type': 'eq', 'fun': lambda weights: np.sum(weights) - 1},  # 비중의 합은 1
)
bounds = [(0, 1) for _ in range(3)]  # 각 주식의 비중은 0에서 1 사이

# 최적화 실행
initial_guess = [1/3, 1/3, 1/3]  # 초기 비중 추측값
result = minimize(portfolio_variance, initial_guess, bounds=bounds, constraints=constraints)
optimal_weights = result.x

portfolio_expected_return = np.sum(optimal_weights * expected_returns)
portfolio_variance_value = portfolio_variance(optimal_weights)

print('Expected Return : ' + str(np.round(portfolio_expected_return*100.0,2)) +'%')
print('Expected Standard Deviation : ' + str(np.round(np.sqrt(portfolio_variance_value)*100.0,2)) +'%')


optimal_weights_percentage = np.round(optimal_weights * 100, 2)
optimal_weights_str = ['{:.2f}%'.format(weight) for weight in optimal_weights_percentage]

print('Optimal Weights For [A,B,C] : ' + str(optimal_weights_str))
print('Expected Return : ' + str(np.round(portfolio_expected_return*100.0,2)) +'%')
print('Expected Standard Deviation : ' + str(np.round(np.sqrt(portfolio_variance_value)*100.0,2)) +'%')
```

```
Optimal Weights For [A,B,C] : ['29.77%', '36.50%', '33.73%']
Expected Return : 4.03%
Expected Standard Deviation : 17.39%
```

그런데 우리는 사실 위험을 최소화 하는 포트폴리오를 찾고 싶은게 아닌 경우가 많습니다. 적절한 위험 하에서 기대수익률을 극대화 하고 싶은 경우가 더 많습니다.
이때는 사용자의 목적에 따라 최적화된 포트폴리오의 결과가 수없이 많아집니다.

**기대수익률 극대화 최적화 코드**

기존의 코드는 포트폴리오의 분산을 최소화하는 것을 목표로 하고 있습니다. 이제는 포트폴리오의 표준편차(standard deviation)를 20% 이내로 제한하면서 기대수익률을 최대화하는 것을 목표로 하는 코드를 작성하겠습니다.
표준편차를 20%로 제한하려면 분산을 $0.20^2=0.04$로 제한하면 됩니다.
***이 포트폴리오로 만들수 있는 최저 표준편차는 17.39%이므로 이것보다는 커야 합니다.***

```python
import numpy as np
from scipy.optimize import minimize

# 주식 3개의 기대수익률, 분산, 공분산 설정
expected_returns = np.array([0.04, 0.05, 0.03])  # 각 주식의 기대수익률
cov_matrix = np.array([
    [0.1, 0.002, -0.001],  # 주식 1의 분산, 1과 2의 공분산, 1과 3의 공분산
    [0.002, 0.08, 0.001],  # 주식 2의 분산, 2와 1의 공분산, 2와 3의 공분산
    [-0.001, 0.001, 0.09]  # 주식 3의 분산, 3과 1의 공분산, 3과 2의 공분산
])

# 포트폴리오의 분산을 계산하는 함수
def portfolio_variance(weights):
    return weights.T @ cov_matrix @ weights

# 패널티 항 추가: 분산이 0.04를 초과하면 패널티 부여
def portfolio_return_with_penalty(weights):
    penalty = 1000  # 패널티 값
    variance = portfolio_variance(weights)
    if variance > 0.04:
        return -np.sum(weights * expected_returns) + penalty
    else:
        return -np.sum(weights * expected_returns)

# 제약 조건
constraints = (
    {'type': 'eq', 'fun': lambda weights: np.sum(weights) - 1},  # 비중의 합은 1
    {'type': 'eq', 'fun': lambda weights: portfolio_variance(weights) - 0.04}  # 분산 제한
)


bounds = [(0, 1) for _ in range(3)]  # 각 주식의 비중은 0에서 1 사이
# 최적화 실행
initial_guess = [1/3, 1/3, 1/3]  # 초기 비중 추측값
result = minimize(portfolio_return_with_penalty, initial_guess, bounds=bounds, constraints=constraints)

optimal_weights = result.x
portfolio_expected_return = np.sum(optimal_weights * expected_returns)
portfolio_variance_value = portfolio_variance(optimal_weights)

optimal_weights_percentage = np.round(optimal_weights * 100, 2)
optimal_weights_str = ['{:.2f}%'.format(weight) for weight in optimal_weights_percentage]
optimal_weights_str, portfolio_expected_return, np.sqrt(portfolio_variance_value)

print('Optimal Weights For [A,B,C] : ' + str(optimal_weights_str))
print('Expected Return : ' + str(np.round(portfolio_expected_return*100.0,2)) +'%')
print('Expected Standard Deviation : ' + str(np.round(np.sqrt(portfolio_variance_value)*100.0,2)) +'%')
```

```
Optimal Weights For [A,B,C] : ['28.54%', '61.42%', '10.04%']
Expected Return : 4.51%
Expected Standard Deviation : 20.0%
```

표준편차를 20% 이내로 제한한 다음 기대수익률을 4.51%로 극대화 했습니다.

다음은 목적함수를 변경하여 포트폴리오의 기대수익률을 최대화하도록 변경하겠습니다.

**기대수익률 - 위험*K 형식의 목표 최적화 함수 코딩**

실무에서 가장 많이 사용하는 방법이 아닐까 합니다.

특별한 제약 조건을 넣지 않고 목적함수를 최대화 하는 방향으로 최적화를 수행합니다.
가장 보편적인 목적함수는 기대수익률 - K*위험을 목적식으로 두는 방법입니다.
기대수익률을 극대화 하되 위험이 높으면 일정 수준의 패널티를 주는 방법으로 제약조건이 없기 때문에 어떻게든 최적의 해가 나온다는 장점이 있습니다.

K는 모델링을 하는 경우도 있고, Try-Error를 통해 자의적으로 판단하기도 합니다.
최적 K값을 찾기 위해 머신러닝을 수행하는 경우도 있었습니다.
현실에서는 매니저가 자의적으로 판단하는 경우가 제일 많고, 그 다음으로는 여러 K값을 테스트 해본 다음 결과가 가장 괜찮았던 수치를 취하는 방식이 그 다음입니다.
일단 페널티를 0.1로 두고 코드를 수행했습니다.

```python
import numpy as np
from scipy.optimize import minimize

# 주식 3개의 기대수익률, 분산, 공분산 설정
expected_returns = np.array([0.04, 0.05, 0.03])
cov_matrix = np.array([
    [0.1, 0.002, -0.001],
    [0.002, 0.08, 0.001],
    [-0.001, 0.001, 0.09]
])

# 목적함수: 기대수익률 - Penalty*분산
def objective_function(weights):
    penalty = 0.1
    return -(np.sum(weights * expected_returns) - penalty * portfolio_variance(weights))

# 포트폴리오의 분산을 계산하는 함수
def portfolio_variance(weights):
    return weights.T @ cov_matrix @ weights

# 제약 조건 설정: 비중의 합은 1
constraints = {'type': 'eq', 'fun': lambda weights: np.sum(weights) - 1}
bounds = [(0, 1) for _ in range(3)]

# 최적화 실행
initial_guess = [1/3, 1/3, 1/3]
result = minimize(objective_function, initial_guess, bounds=bounds, constraints=constraints)
optimal_weights = result.x

# 결과 출력
portfolio_expected_return = np.sum(optimal_weights * expected_returns)
portfolio_variance_value = portfolio_variance(optimal_weights)

optimal_weights_percentage = np.round(optimal_weights * 100, 2)
optimal_weights_str = ['{:.2f}%'.format(weight) for weight in optimal_weights_percentage]

print('Optimal Weights For [A,B,C]:', optimal_weights_str)
print('Expected Return:', np.round(portfolio_expected_return * 100, 2), '%')
print('Expected Standard Deviation:', np.round(np.sqrt(portfolio_variance_value) * 100, 2), '%')
```

```
Optimal Weights For [A,B,C]: ['15.91%', '84.09%', '0.00%']
Expected Return: 4.84 %
Expected Standard Deviation: 24.42 %
```

결과는 기대수익률이 높은 B종목에 거의 비중을 몰아주고 가장 위험이 낮은 C종목 비중은 0%로 두는 포트폴리오를 산출했습니다. 위험에 대한 패널티가 낮기 때문입니다. 보다 위험 회피적인 투자자는 패널티를 늘려서 원하는 포트폴리오를 산출할 수 있습니다.


#### 각종 제약 조건들

**섹터 또는 산업 제약**

많은 포트폴리오 매니저, 특히 벤치마크를 기준으로 관리하는 매니저는 포트폴리오의 섹터별 가중치를 제한하고 싶어합니다.
$$
\underline{w}_j \geq w_j \leq \overline{w}_j
$$

여기서 $w_j$는 포트폴리오에서 섹터j의 비중을 나타냅니다.

**거래량 제한**

기본적으로 포트폴리오는 규모가 개인 투자자들에 비해 상당하기 때문에 거래량이 일정 수준 이하인 종목은 매매할 수 없거나 적은 비중만이 투자 가능합니다. 거래량에 따라 비중에 제약을 가할 수 있습니다.
예를들어 포트폴리오의 가치가 5000억원이고 한 종목의 보유량을 해당 종목의 일일 평균 거래량 10% 미만으로 유지하려 한다고 가정합니다. 그럼 제약 조건은 다음과 같습니다.

$$
    5000*w_i \leq 0.1*ADV_i
$$

$ADV_i$는 i주식의 일일 평균 거래량이고 $w_i$는 i종목의 비중입니다.
일반화 하면 다음과 같이 표현합니다.

$$
    w \leq cx
$$

w는 주식의 비중 벡터이고 c는 상수이며 x는 일일거래량 벡터입니다.


#### 벤치마크가 있는 포트폴리오 비중 결정

대부분의 포트폴리오 매니저는 벤치마크에 비교하여 포트폴리오를 관리합니다. 벤치마크에 매우 근접하게 운용하는 매니저를 '인덱스 매니저'라고 부르기도 하지만, 벤치마크에 매우 느슨하게 운용하는 매니저는 '액티브 매니저' 또는 '향상된 인덱스 매니저'라고 부르는 것이 더 정확합니다. 액티브 매니저의 목표는 기본 벤치마크와 대체로 유사하지만, 벤치마크보다 일정 수준 초과하는 주식 포트폴리오를 구성하는 것입니다. 일반적인 운용사에서 매니저는 벤치마크에서 크게 벗어나지 않으면서, 벤치마크를 능가하는 성과를 내기 위해 일정한 차이를 유지해야 합니다. 너무 벗어나면 위규를 발생한다고 판단하여 제재가 들어오는 경우도 많습니다.

**가장 간단한 방법 : AdHoc**

간단한 방법 중 하나는 포트폴리오에서 벤치마크의 가장 큰 보유 종목을 선택하는 것입니다. 예를 들어, 포트폴리오에 50개의 주식이 포함될 경우, 이는 포트폴리오에서 가장 큰 비중을 차지하는 50개의 주식을 선택하는 것과 같습니다.

물론 매니저는 선호하는 종목에 가중치를 약간 더 줄수 있습니다. 앞서 배운 Z점수에 따라 비중을 할당할 수도 있고 자의적인 판단으로 더 비중을 할당할 수도 있습니다.

**계층화 방식**

계층화 또는 계층화 샘플링은, 초보적인 위험 관리 메커니즘을 유지하면서 포트폴리오를 구축할 수 있는 간단한 방법 중 하나입니다.
매니저는 자신이 보유한 모든 종목의 알파예측 모델이 있다고 가정합니다. 벤치마크 대비 리스크를 관리하면서 알파가 높은 종목을 선택하는 것이 목표입니다.계층화의 첫 번째 단계는 주식 유니버스를 겹치지 않는 J개의 그룹으로 나누어 계층화하는 것입니다. 예를 들어, 주식을 산업 버킷으로 나누어 각 계층이 다른 산업을 나타낼 수 있습니다.
계층화 샘플링의 다음 단계는 각 계층에서 대표 종목을 선택하는 것입니다. 포트폴리오 관리자는 포트폴리오에 얼마나 많은 주식을 포함할지 결정해야 합니다. 
전체 주식수를 N, 포트폴리오에 포함할 주식수를 $N_P$, 계층i에 포함된 주식수를 $N_i$라고 하면 매니저는 각 계층에서 $N_i \frac{N_P}{N}$개 종목을 선택해야 합니다.

계층에서 종목을 선택하기 전에 총 Z-점수, 기대 수익률, 초과 수익률, 초과 수익률에 따라 각 계층에 있는 종목의 순위를 매겨야 합니다. 선택한 기준의 값이 가장 높은 종목을 선택합니다.

계층화는 선호하는 종목을 선택하는 동시에, 폭넓은 분산으로 위험을 관리할 수 있는 간편한 방법입니다. 여러 산업이나 섹터에 걸쳐 계층화를 하면, 벤치마크에 비해 폭넓은 분산과 위험 통제가 가능합니다. 그러나 계층화의 가장 큰 단점은, 리스크를 통제하는데 있어 상당히 초보적인 방법이라는 점입니다. 계층화에는 정확하고 정량적인 통제 메커니즘이 부족하다는 것이 명확합니다.

**팩터 노출 타게팅**

포트폴리오를 벤치마크와 일치시키는 또 다른 방법은, 벤치마크의 팩터 익스포저를 포트폴리오의 목표 팩터 익스포저로 설정하는 것입니다. 예를들어 벤치마크 대비 포트폴리오의 전체 베타를 1.0 과 같거나 매우 가깝게 설정할 수도 있습니다.

$\beta$를 개별 종목의 벤치마크 베타의 N차원 열 벡터라고 합니다.

$$
\beta
=
\begin{bmatrix}
\beta_1 \\
\beta_2 \\
\vdots \\
\beta_N 
\end{bmatrix}
$$


여기서 $\beta_i$는 벤치마크에 대한 주식 i의 베타입니다. 포트폴리오 베타는 $w'\beta$와 같습니다. 최적화 수식에 다음과 같은 제약 조건을 추가하면 포트폴리오의 베타가 1.0이 되도록 최적화를 수행합니다.
$$
w'\beta = 1 
$$

또는 포트폴리오 $\beta$의 범위를 지정할 수도 있습니다.

$$
0.75 \geq w'\beta \leq 1.25
$$

이 작업은 포트폴리오의 다른 팩터 노출도에 대해서도 제약할 수 있습니다.
포트폴리오의 팩터 노출도는 개별 종목의 팩터 노출도를 가중평균한 값입니다.

B를 N개의 종목의 K개의 팩터에 대한 팩터 노출도 N X K 행렬이라고 합니다.

$$
B = \begin{bmatrix}
\beta_{11} & \beta_{12} & \dots & \beta_{1K} \\
\beta_{21} & \beta_{22} & \dots & \beta_{2K} \\
\vdots & \vdots & \ddots & \vdots \\
\beta_{N1} & \beta_{N2} & \dots & \beta_{NK} \\
\end{bmatrix}
$$

그럼 가중치 w를 가진 포트폴리오의 팩터 노출은 간단하게 B'w가 됩니다.
따라서 다음과 같이 팩터별로 제약조건을 설정할 수 있습니다.

$$
    \underline{\beta} \geq B'w \leq \overline{\beta}
$$

포트폴리오 매니저는 이러한 제약을 통해 자신의 고유한 운용 스타일을 적용할 수 있습니다.

**추적오류 최소화(Tracking Error)**

대부분의 전문 포트폴리오 매니저는 벤치마크가 있는 경우 '추적 오차 최소화 접근법'을 사용하여 주식에 가중치를 부여하고 포트폴리오를 구축합니다. 이 접근법을 사용하여 최적화 문제를 공식화하는 방법에는 두 가지가 있습니다. 한 가지 방법은 벤치마크 대비 예상 초과수익률에 대한 추적 오차를 최소화하는 것이며, 다른 하나는 벤치마크 대비 예상 초과수익률을 최대화하는 것입니다.

추적 오차는 대부분 포트폴리오 수익률에서 벤치마크 수익률을 뺀 표준편차로 정의합니다.
$$
TE = S(r_P-r_B) = \sqrt{V(r_P-r_B)}, \quad
V(r_P-r_B) = V(r_P) - 2C(r_P,r_B) + V(r_B)
$$

추적 오차를 최소화 하는 포트폴리오를 찾으려면 $V(r_P) - 2C(r_P,r_B)$를 최소화 합니다. $V(r_B)$는 우리가 통제할수 없는 영역입니다.

포트폴리오 가중치 w 가 주어지면, 포트폴리오의 분산은 w′Σw로 주어집니다. w는 포트폴리오의 가중치 벡터이고 Σ 는 수익률의 공분산 행렬입니다. 
포트폴리오와 벤치마크 간의 공분산은 개별 주식 수익률과 벤치마크 수익률 간의 공분산으로부터 계산할 수 있습니다. $\gamma$ 는 개별 주식 수익률과 벤치마크 수익률 간의 공분산의 N차원 벡터라고 합니다.

$$
\gamma
=
\begin{bmatrix}
C(r_1,r_B) \\
C(r_2,r_B) \\
\vdots \\
C(r_N,r_B) \\
\end{bmatrix}
$$

추적오류를 최소화 하는 포트폴리오를 찾으려면 다음과 같은 이차최소화문제를 풀면 됩니다.

$$
\underset{w}{min}\ w' \Sigma w - 2w'\gamma \quad s.t. \quad w'\mu = \mu_p \quad
$$

## 마치며

이번에는 팩터를 예측하고 트폴리오에 가중치를 할당하는 다양한 방법을 검토하고, 이러한 방법들의 장단점을 평가했습니다. 
최적화 부분은 더 깊게 들어갈 여지가 있으나 실무에서 사용하는 기본적인 최적화는 충분히 짚었습니다.

